{"meta":{"title":"小耳朵","subtitle":null,"description":null,"author":"Duer","url":"http://xerduo.com"},"pages":[{"title":"","date":"2021-03-05T13:58:59.927Z","updated":"2021-03-05T13:58:59.927Z","comments":true,"path":"google184e1e684149229c.html","permalink":"http://xerduo.com/google184e1e684149229c.html","excerpt":"","text":"google-site-verification: google184e1e684149229c.html"},{"title":"","date":"2018-01-19T06:58:08.000Z","updated":"2021-03-05T13:58:59.924Z","comments":true,"path":"about/index.html","permalink":"http://xerduo.com/about/index.html","excerpt":"","text":"关于我123456789&#123; \"name\": \"Duer\", \"address\": \"广东省深圳市\", \"education\": \"本科/贵州大学\", \"Github\": \"https://github.com/adoer\", \"blog\": \"www.xerduo.com\", \"email\": \"duqingbetter@qq.com\", \"company\": \"格创东智\",&#125;"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2021-03-05T13:58:59.925Z","comments":false,"path":"categories/index.html","permalink":"http://xerduo.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2021-03-05T13:58:59.928Z","comments":true,"path":"tags/index.html","permalink":"http://xerduo.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Windows结束某个端口的进程","slug":"Windows结束某个端口的进程","date":"2021-03-08T13:04:12.000Z","updated":"2021-03-08T13:22:56.250Z","comments":true,"path":"2021/03/08/Windows结束某个端口的进程/","link":"","permalink":"http://xerduo.com/2021/03/08/Windows结束某个端口的进程/","excerpt":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。","text":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。2.根据PID找进程名称，输入命令：1tasklist | findstr 2181 发现是占用8080端口的进程为：javaw.exe。 3.根据PID结束对应进程。输入命令：1taskkill -PID 2188 -F 强制关闭PID为2188的进程。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/tags/Windows/"}]},{"title":"JS类型检测","slug":"js类型检测","date":"2021-03-08T08:51:08.000Z","updated":"2021-03-08T13:17:41.620Z","comments":true,"path":"2021/03/08/js类型检测/","link":"","permalink":"http://xerduo.com/2021/03/08/js类型检测/","excerpt":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。","text":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。 typeof 1234567891011console.log(typeof \"\"); // string 有效console.log(typeof 1); // number 有效console.log(typeof Symbol()); // symbol 有效console.log(typeof true); // boolean 有效console.log(typeof undefined); // undefined 有效console.log(typeof null); // object 有效console.log(typeof []); // object 有效console.log(typeof function()&#123;&#125;); // function 有效console.log(typeof &#123;&#125;); // objectconsole.log(typeof new Date()); // objectconsole.log(typeof new RegExp()); // object 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： constructorObject.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ;// [object Boolean]Object.prototype.toString.call(Symbol());//[object Symbol]Object.prototype.toString.call(undefined) ;// [object Undefined]Object.prototype.toString.call(null) ;// [object Null]Object.prototype.toString.call(newFunction()) ;// [object Function]Object.prototype.toString.call(newDate()) ;// [object Date]Object.prototype.toString.call([]) ;// [object Array]Object.prototype.toString.call(newRegExp()) ;// [object RegExp]Object.prototype.toString.call(newError()) ;// [object Error]Object.prototype.toString.call(document) ;// [object HTMLDocument]Object.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"null与undefined","slug":"null与undefined","date":"2021-03-08T02:50:11.000Z","updated":"2021-03-08T12:39:16.281Z","comments":true,"path":"2021/03/08/null与undefined/","link":"","permalink":"http://xerduo.com/2021/03/08/null与undefined/","excerpt":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。","text":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为 了正式明确空对象指针（null）和未初始化变量的区别。 null Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：let car = null;console.log(typeof car); // “object”在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用 （1）在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。 // （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype)// null 检测1、可以使用 String()转型函数，它始终会返回表示相应类型值的字符串12String(null) // &apos;null&apos; ,String(undefined) // &apos;undefined&apos; 2、使用 Object.prototype.toString.call(arg)12Object.prototype.toString.call(undefined) ; // &quot;[object Undefined]&quot;Object.prototype.toString.call(null) ; // &quot;[object Null]&quot; 历史原因1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。 1234Number(null)// 05 + null// 5 但是，JavaScript的设计者Brendan Eich（布兰登·艾克），觉得这样做还不够，有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"🎮基于canvas的俄罗斯方块游戏","slug":"基于canvas的俄罗斯方块游戏","date":"2021-01-03T07:00:53.000Z","updated":"2021-03-05T13:58:59.924Z","comments":true,"path":"2021/01/03/基于canvas的俄罗斯方块游戏/","link":"","permalink":"http://xerduo.com/2021/01/03/基于canvas的俄罗斯方块游戏/","excerpt":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;);","text":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;); 界面预览游戏开始 游戏进行中 游戏结束","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://xerduo.com/tags/游戏/"}]},{"title":"两数相加","slug":"两数相加","date":"2021-01-01T03:41:50.000Z","updated":"2021-03-05T13:58:59.922Z","comments":true,"path":"2021/01/01/两数相加/","link":"","permalink":"http://xerduo.com/2021/01/01/两数相加/","excerpt":"题意You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。","text":"题意You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 例如：123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; // 假设l1,l2是数组(其实是链表) 需要理解链表概念 因为 l1 l1 是非空链表 // 将链表转化为数组 let arrL1,arrL2; let dealListNode=function(arg)&#123; // 递归 let arr=[]; let curItemConst=arg; function fun(curItem)&#123; if(curItem)&#123; arr.push(curItem['val']); curItemConst=curItem['next']; fun(curItemConst); &#125; &#125; fun(curItemConst); return arr; &#125; arrL1=dealListNode(l1); arrL2=dealListNode(l2); //判断哪个长 var arr=arrL1.length&gt;arrL2.length?arrL1:arrL2; // 结果数组,// 进位数组 let result=[],cache=[]; for(let i=0, l=arr.length; i&lt;l; i++)&#123; let curL1=arrL1[i]||0; let curL2=arrL2[i]||0; cache[i]=cache[i]||0; let res=curL1+curL2+cache[i]; if(res&lt;10)&#123; result[i]=res; &#125;else&#123; result[i]=res%10; cache[i+1]=1; &#125; &#125; if(cache.length&gt;arr.length)&#123; result=[...result,1] &#125; return result;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://xerduo.com/tags/刷题/"}]},{"title":"两数之和","slug":"TwoSum","date":"2018-01-18T05:06:00.000Z","updated":"2021-03-05T13:58:59.921Z","comments":true,"path":"2018/01/18/TwoSum/","link":"","permalink":"http://xerduo.com/2018/01/18/TwoSum/","excerpt":"题意Given an array of integers, return indices of the two numbers such that they add up to a specific target，You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整数数组，返回其中两个数的索引，并使索引对应元素之和与给定的数相等，假定每次输入都只有一个解决方案，并且不会使用相同的元素两次。","text":"题意Given an array of integers, return indices of the two numbers such that they add up to a specific target，You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整数数组，返回其中两个数的索引，并使索引对应元素之和与给定的数相等，假定每次输入都只有一个解决方案，并且不会使用相同的元素两次。 例如：123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 代码123456789101112131415/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; var map = &#123;&#125;; for (var i = 0, l = nums.length; i &lt; l; i++) &#123; if (map[target - nums[i]] !== undefined) &#123; return [map[target - nums[i]], i]; &#125; else &#123; map[nums[i]] = i; &#125; &#125;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://xerduo.com/tags/刷题/"}]}]}